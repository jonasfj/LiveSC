// Generated by CoffeeScript 1.3.3
(function() {
  var Applet, checkAppletReady, executeCheck, initialized, initializing, nextModel, spinner, synthesize, _ref;

  if ((_ref = this.LSC) == null) {
    this.LSC = {};
  }

  this.LSC.Applet = Applet = {};

  initialized = false;

  initializing = false;

  nextModel = null;

  synthesize = false;

  Applet.initialize = function() {
    if (!(initializing || initialized)) {
      $("body").append('<applet id="applet" style="visibility: hidden; position: absolute;" code="Applet" archive="bin/Applet.jar,bin/jtlv.jar,bin/antlr-runtime-3.0.1.jar,bin/javabdd-2.0.jar,bin/jdd.jar,bin/scala-library.jar" width="1" height="1" mayscript="true" scriptable="true"></applet>');
      initializing = true;
      $("#apploading").fadeIn(cfg.animation.speed);
      setTimeout(checkAppletReady, 500);
    }
    return initialized;
  };

  checkAppletReady = function() {
    var app;
    app = document.getElementById("applet");
    if (!app.loadSMV) {
      return setTimeout(checkAppletReady, 500);
    } else {
      $("#apploading").fadeOut(cfg.animation.speed);
      initializing = false;
      initialized = true;
      return executeCheck();
    }
  };

  Applet.check = function(model) {
    if (model != null) {
      nextModel = model;
      synthesize = false;
      if (Applet.initialize()) {
        return executeCheck();
      }
    } else {
      return log("No model was provided.");
    }
  };

  Applet.synthesize = function(model) {
    if (model != null) {
      nextModel = model;
      synthesize = true;
      if (Applet.initialize()) {
        return executeCheck();
      }
    } else {
      return log("No model was provided.");
    }
  };

  executeCheck = function() {
    var app, exit, result, unspin;
    if (nextModel == null) {
      log("Failed to find next model");
      return;
    }
    app = document.getElementById("applet");
    unspin = spinner("spinner");
    exit = function() {
      return $("#progressdialog").fadeOut(cfg.animation.speed, function() {
        $("#operation").html("");
        $("#console").html("");
        unspin();
        $("#closeprogress").off('exit');
        return $("#closeprogress").hide();
      });
    };
    $("#closeprogress").click(exit);
    $("#progressdialog").fadeIn(cfg.animation.speed);
    $("#operation").html("Loading Model...");
    try {
      if (app.loadSMV(nextModel)) {
        $("#operation").html("Checking Realizability...");
        if (app.game() === null) {
          reportProgress("Failed loading transition system.");
        }
        if (app.game().realizable()) {
          $("#operation").html("Synthesizing Strategy...");
          if (synthesize) {
            result = parseInt(app.game().synthesize()) || -1;
            if (result >= 0) {
              $("#operation").html("Strategy Synthesized");
            } else {
              $("#operation").html("Synthesis Failed");
            }
          } else {
            $("#operation").html("Model is Realizable");
          }
        } else {
          $("#operation").html("Model is Not Realizable");
        }
      }
    } catch (error) {
      $("#operation").html("Model Checking Failed");
      reportProgress("\nError: " + error);
    }
    $("#closeprogress").show();
    unspin();
    return nextModel = null;
  };

  this.reportProgress = function(info) {
    $("#console").html($("#console").html() + info);
    return $("#console").scrollTop($("#console")[0].scrollHeight);
  };

  spinner = function(placeholder) {
    var alpha, beta, canvas, color, cos, cx, cy, i, opacity, pathParams, r1, r2, sectors, sectorsCount, sin, tick, ticker, width, _i;
    width = 15;
    color = "#000";
    pathParams = {
      "stroke": color,
      "stroke-width": width,
      "stroke-linecap": "round"
    };
    sectorsCount = 12;
    r1 = 35;
    r2 = 60;
    cx = r2 + width;
    cy = r2 + width;
    beta = 2 * Math.PI / sectorsCount;
    canvas = Raphael(placeholder, r2 * 2 + width * 2, r2 * 2 + width * 2);
    sectors = [];
    opacity = [];
    Raphael.getColor.reset();
    for (i = _i = 0; 0 <= sectorsCount ? _i <= sectorsCount : _i >= sectorsCount; i = 0 <= sectorsCount ? ++_i : --_i) {
      alpha = beta * (i - Math.PI / 2);
      cos = Math.cos(alpha);
      sin = Math.sin(alpha);
      opacity[i] = 1 / sectorsCount * i;
      sectors[i] = canvas.path([["M", cx + r1 * cos, cy + r1 * sin], ["L", cx + r2 * cos, cy + r2 * sin]]).attr(pathParams);
    }
    tick = 0;
    ticker = function() {
      var _j, _results;
      opacity.unshift(opacity.pop());
      _results = [];
      for (i = _j = 0; 0 <= sectorsCount ? _j <= sectorsCount : _j >= sectorsCount; i = 0 <= sectorsCount ? ++_j : --_j) {
        _results.push(sectors[i].attr({
          "opacity": opacity[i]
        }));
      }
      return _results;
    };
    canvas.safari();
    tick = setInterval(ticker, 1000 / sectorsCount);
    return function() {
      clearInterval(tick);
      return canvas.remove();
    };
  };

}).call(this);

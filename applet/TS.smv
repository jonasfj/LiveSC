MODULE small
VAR
	geek : {code, pizza, sleep};
ASSIGN
	init(geek) :=  code;
	next(geek) :=
		case
			geek = code			: {code, pizza};
			geek = pizza		: sleep;
			geek = sleep		: {sleep, code};
		esac;

MODULE main
VAR
	o : output(i.wake, i.sleep, i.gbuchi, i.active1, i.active2, i.locEnvLSC1, i.locEnvLSC2, i.envreq);
	i : input(o.fall, o.make, o.locSys1LSC1, o.locSys2LSC1, o.locSys1LSC2, o.locSys2LSC2, o.currentprocess);
--	g : small;

MODULE input(fall, make, locSys1LSC1, locSys2LSC1, locSys1LSC2, locSys2LSC2, currentprocess)
VAR
	wake : boolean; --the”wake”message
	sleep : boolean; --the”sleep”message
	gbuchi : 0..2; --auxiliaryvariable
	active1 : boolean; --whenLSC1mainchartisactive
	active2 : boolean; --1whenLSC2mainchartisactive
	locEnvLSC1 : 0..2;
	locEnvLSC2 : 0..4;
	envreq : 0..0; --only1environmentobject(0)

ASSIGN
	init(wake) := 0;
	next(wake) := 
		case
			next(currentprocess) != 0 :0;
			next(fall) = 0 & next(make) = 0 & next(sleep) = 0 & active1 = 0 : {0,1};
			1 : 0;
		esac;

	init(sleep) :=0;
	next(sleep) := 
		case
			next(currentprocess) != 0 : 0;
			next(wake) = 0 & next(fall) = 0 & next(make) = 0 & active2 = 0 : {0,1};
			1 : 0;
		esac;

	init(gbuchi) :=0;
	next(gbuchi) := 
		case
			gbuchi = 0 :1;
			gbuchi = 1 & active1 = 0 & active2 = 0 : 2;
			gbuchi = 2 & currentprocess < 1 : 0;
			1 : gbuchi;
		esac;

	init(active1) := 0;
	next(active1) := 
		case
			active1 = 0 & next(locEnvLSC1) = 1 :1;
			active1 = 1 & next(locEnvLSC1) = 1 & next(locSys1LSC1) = 1 & next(locSys2LSC1) = 1 :0;
			1 : active1;
		esac;

	init(active2) :=0;
	next(active2) := 
		case
			active2=0 & next(locEnvLSC2)=2 & next(locSys1LSC2)=2 & next(locSys2LSC2)=3 :1; --Thereisnowaytotransitionbacktoaninactivestate
			1 :active2;
		esac;

	init(locEnvLSC1) := 0;
	next(locEnvLSC1) := 
		case
			active1 = 0 & locEnvLSC1 = 1 :0;
			next(currentprocess) = 0 & locEnvLSC1 = 0 & next(wake) = 1 : 1;
			1 : locEnvLSC1;
		esac;

	init(locEnvLSC2) := 0;
	next(locEnvLSC2) := 
		case
			active2 = 0 & locEnvLSC2 > 3 : 0;
			next(currentprocess) = 0 & locSys2LSC2 = 2 & locEnvLSC2 = 0 : 1;
			next(currentprocess) = 0 & locEnvLSC2 = 1 & next(sleep) = 1 : 2;
			next(currentprocess) = 2 & locEnvLSC2 = 0 & next(locSys2LSC2) = 3 : 1;
			next(currentprocess) = 0 & locEnvLSC2 = 2 & locSys1LSC2 = 2 & locSys2LSC2 = 3 : 4;
			next(currentprocess) = 1 & locEnvLSC2 = 2 & next(locSys1LSC2) = 4 : 4;
			next(currentprocess) = 2 & locEnvLSC2 = 2 & next(locSys2LSC2) = 5 : 4;
			1 : locEnvLSC2;
		esac;

	init(envreq) := 0;
	next(envreq) := 0;

DEFINE
	q:= gbuchi = 0;

MODULE output (wake, sleep, gbuchi, active1, active2, locEnvLSC1, locEnvLSC2, envreq)
VAR
	fall : boolean; --the”fall”message
	make : boolean; --the”make”message
	locSys1LSC1 : 0..1;
	locSys2LSC1 : 0..1;
	locSys1LSC2 : 0..4;
	locSys2LSC2 : 0..5;
	currentprocess : 0..2;
ASSIGN
	init(fall):=0;
	next(fall):=
		case
			next(currentprocess) != 1 : 0;
			active1 = 1 & locSys1LSC1 = 0 & next(locSys1LSC1) = 1 & next(wake) = 0 & next(sleep) = 0 & next(make) = 0 : 1;
			1 :0;
		esac;

	init(make) := 0;
	next(make) :=
		case
			next(currentprocess)!= 2 : 0;
			active1 = 1 & locSys2LSC1 = 0 & next(locSys2LSC1 )= 1 & next(wake) = 0 & next(sleep) = 0 & next(fall) = 0 : 1;
			1 : 0;
		esac;

	init(locSys1LSC1) := 0;
	next(locSys1LSC1) :=
		case
			active1 = 0 & locSys1LSC1 > 0 : 0;
			next(currentprocess) = 1 & locSys1LSC1 = 0 & next(fall) = 1 :1;
			1 : locSys1LSC1;
		esac;

	init(locSys2LSC1) := 0;
	next(locSys2LSC1) :=
		case
			active1 = 0 & locSys2LSC1 > 0 : 0;
			next(currentprocess) = 2 & locSys2LSC1 = 0 & next(make) = 1 : 1;
			1 : locSys2LSC1;
		esac;

	init(locSys1LSC2) := 0;
	next(locSys1LSC2) :=
		case
			active2 = 0 & locSys1LSC2 > 3 : 0;
			next(currentprocess) = 1 & locSys1LSC2 = 0 & next(fall) = 1 : 1;
			next(currentprocess) = 1 & locSys1LSC2 = 1 & locSys2LSC2 = 0 : 2;
			next(currentprocess) = 2 & locSys1LSC2 = 1 & next(locSys2LSC2) = 1 : 2;
			next(currentprocess) = 0 & locSys1LSC2 = 2 & next(locEnvLSC2) = 4 : 4;
			next(currentprocess) = 1 & locSys1LSC2 = 2 & locEnvLSC2 = 2 & locSys2LSC2 = 3 : 4;
			next(currentprocess) = 2 & locSys1LSC2 = 2 & next(locSys2LSC2) = 5 : 4;
			1 : locSys1LSC2;
		esac;

	init(locSys2LSC2) := 0;
	next(locSys2LSC2) :=
		case
			active2=0 & locSys2LSC2 > 4 : 0;
			next(currentprocess) = 0 & locSys2LSC2 = 2 & next(locEnvLSC2) = 1 : 3;
			next(currentprocess) = 1 & locSys2LSC2 = 0 & next(locSys1LSC2) = 2 : 1;
			next(currentprocess) = 2 & locSys1LSC2 = 1 & locSys2LSC2 = 0 : 1;
			next(currentprocess) = 2 & locSys2LSC2 = 1 & next(make) = 1 : 2;
			next(currentprocess) = 2 & locSys2LSC2 = 2 & locEnvLSC2 = 0 : 3;
			next(currentprocess) = 0 & locSys2LSC2 = 3 & next(locEnvLSC2) = 4 : 5;
			next(currentprocess) = 1 & locSys2LSC2 = 3 & next(locSys1LSC2) = 4 : 5;
			next(currentprocess) = 2 & locSys2LSC2 = 3 & locSys1LSC2 = 2 & locEnvLSC2 = 2 : 5;
			1 : locSys2LSC2;
		esac;

	init(currentprocess) := {envreq,1,2}; --select:environment,Sys1,Sys2
	next(currentprocess) := {envreq,1,2};
